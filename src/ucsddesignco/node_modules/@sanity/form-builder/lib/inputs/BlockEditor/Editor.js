"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isEqual2 = _interopRequireDefault(require("lodash/isEqual"));

var _react = _interopRequireDefault(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _slateSoftBreak = _interopRequireDefault(require("slate-soft-break"));

var _slateReact = require("slate-react");

var _isHotkey = require("is-hotkey");

var _slateInsertBlockOnEnter = _interopRequireDefault(require("slate-insert-block-on-enter"));

var _onPaste = _interopRequireDefault(require("part:@sanity/form-builder/input/block-editor/on-paste?"));

var _onCopy = _interopRequireDefault(require("part:@sanity/form-builder/input/block-editor/on-copy?"));

var _PatchEvent = _interopRequireWildcard(require("../../../PatchEvent"));

var _createOperationToPatches = require("./utils/createOperationToPatches");

var _buildEditorSchema = _interopRequireDefault(require("./utils/buildEditorSchema"));

var _ExpandToWordPlugin = _interopRequireDefault(require("./plugins/ExpandToWordPlugin"));

var _EnsurePlaceHolderBlockPlugin = _interopRequireDefault(require("./plugins/EnsurePlaceHolderBlockPlugin"));

var _InsertBlockObjectPlugin = _interopRequireDefault(require("./plugins/InsertBlockObjectPlugin"));

var _InsertInlineObjectPlugin = _interopRequireDefault(require("./plugins/InsertInlineObjectPlugin"));

var _ListItemOnEnterKeyPlugin = _interopRequireDefault(require("./plugins/ListItemOnEnterKeyPlugin"));

var _ListItemOnTabKeyPlugin = _interopRequireDefault(require("./plugins/ListItemOnTabKeyPlugin"));

var _OnDropPlugin = _interopRequireDefault(require("./plugins/OnDropPlugin"));

var _OnFocusPlugin = _interopRequireDefault(require("./plugins/OnFocusPlugin"));

var _TogglePlaceHolderPlugin = _interopRequireDefault(require("./plugins/TogglePlaceHolderPlugin"));

var _PastePlugin = _interopRequireDefault(require("./plugins/PastePlugin"));

var _QueryPlugin = _interopRequireDefault(require("./plugins/QueryPlugin"));

var _SetBlockStylePlugin = _interopRequireDefault(require("./plugins/SetBlockStylePlugin"));

var _SetMarksOnKeyComboPlugin = _interopRequireDefault(require("./plugins/SetMarksOnKeyComboPlugin"));

var _TextBlockOnEnterKeyPlugin = _interopRequireDefault(require("./plugins/TextBlockOnEnterKeyPlugin"));

var _ToggleAnnotationPlugin = _interopRequireDefault(require("./plugins/ToggleAnnotationPlugin"));

var _ToggleListItemPlugin = _interopRequireDefault(require("./plugins/ToggleListItemPlugin"));

var _UndoRedoPlugin = _interopRequireDefault(require("./plugins/UndoRedoPlugin"));

var _WrapSpanPlugin = _interopRequireDefault(require("./plugins/WrapSpanPlugin"));

var _FirefoxVoidNodePlugin = _interopRequireDefault(require("./plugins/FirefoxVoidNodePlugin"));

var _FocusNoScrollPlugin = _interopRequireDefault(require("./plugins/FocusNoScrollPlugin"));

var _ScrollAbsoluteTopBottomPlugin = _interopRequireDefault(require("./plugins/ScrollAbsoluteTopBottomPlugin"));

var _ScrollToFocusWithDynamicHeightPreviewPlugin = _interopRequireDefault(require("./plugins/ScrollToFocusWithDynamicHeightPreviewPlugin"));

var _BlockExtrasOverlay = _interopRequireDefault(require("./BlockExtrasOverlay"));

var _BlockObject = _interopRequireDefault(require("./nodes/BlockObject"));

var _ContentBlock = _interopRequireDefault(require("./nodes/ContentBlock"));

var _Decorator = _interopRequireDefault(require("./nodes/Decorator"));

var _InlineObject = _interopRequireDefault(require("./nodes/InlineObject"));

var _Span = _interopRequireDefault(require("./nodes/Span"));

var _Editor = _interopRequireDefault(require("./styles/Editor.css"));

var _blockTools = require("@sanity/block-tools");

var _getKey = require("./utils/getKey");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; if (obj != null) { var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function scrollIntoView(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var element = (0, _slateReact.findDOMNode)(node); // eslint-disable-line react/no-find-dom-node

  element.scrollIntoView({
    behavior: opts.behavior || 'instant',
    block: opts.block || 'center',
    inline: opts.inline || 'nearest'
  });
}

class Editor extends _react.default.Component {
  constructor(_props) {
    super(_props);

    _defineProperty(this, "blockDragMarker", void 0);

    _defineProperty(this, "editorSchema", void 0);

    _defineProperty(this, "editor", _react.default.createRef());

    _defineProperty(this, "plugins", []);

    _defineProperty(this, "handleChange", editor => {
      var _this$props = this.props,
          onChange = _this$props.onChange,
          onFocus = _this$props.onFocus,
          focusPath = _this$props.focusPath;
      var focusBlock = editor.value.focusBlock;
      var path = [];

      if (focusBlock) {
        path.push({
          _key: focusBlock.key
        });
      }

      if (path.length && focusPath && focusPath.length === 1) {
        return onChange(editor, () => onFocus(path));
      }

      return onChange(editor);
    });

    _defineProperty(this, "handleEditorFocus", (event, editor, next) => {
      this.props.setFocus(); // Tell the formbuilder to set focus here

      next(); // Continue Slate's focus plugin stack
    });

    _defineProperty(this, "getValue", () => {
      return this.props.value;
    });

    _defineProperty(this, "getEditor", () => {
      if (this.editor && this.editor.current) {
        return this.editor.current;
      }

      return null;
    });

    _defineProperty(this, "handlePasteProgress", (_ref) => {
      var status = _ref.status;
      var onLoading = this.props.onLoading;
      onLoading({
        paste: status
      });
    });

    _defineProperty(this, "handleShowBlockDragMarker", (pos, node) => {
      // eslint-disable-next-line react/no-find-dom-node
      var editorDOMNode = _reactDom.default.findDOMNode(this.getEditor());

      if (editorDOMNode instanceof HTMLElement) {
        var elemRect = node.getBoundingClientRect();
        var topPos = node.scrollTop + node.offsetTop;
        var bottomPos = node.scrollTop + node.offsetTop + elemRect.height;
        var top = pos === 'after' ? "".concat(bottomPos, "px") : "".concat(topPos, "px");

        if (this.blockDragMarker) {
          this.blockDragMarker.style.display = 'block';
          this.blockDragMarker.style.top = top;
        }
      }
    });

    _defineProperty(this, "handleHideBlockDragMarker", () => {
      if (this.blockDragMarker) {
        this.blockDragMarker.style.display = 'none';
      }
    });

    _defineProperty(this, "handlePaste", (event, editor, next) => {
      event.persist(); // Keep the event through the plugin chain after calling next()

      var onPaste = this.props.onPaste || _onPaste.default;

      if (!onPaste) {
        return next();
      }

      var _this$props2 = this.props,
          focusPath = _this$props2.focusPath,
          onPatch = _this$props2.onPatch,
          onLoading = _this$props2.onLoading,
          value = _this$props2.value,
          type = _this$props2.type;
      onLoading({
        paste: 'start'
      });

      var resolveOnPasteResultOrError = () => {
        try {
          return onPaste({
            event,
            value,
            path: focusPath,
            type
          });
        } catch (error) {
          return error;
        }
      }; // Resolve it as promise (can be either async promise or sync return value)


      var resolved = Promise.resolve(resolveOnPasteResultOrError());
      return resolved.then(result => {
        onLoading({
          paste: null
        });

        if (result === undefined) {
          return next();
        }

        if (result instanceof Error) {
          throw result;
        }

        if (result && result.insert) {
          var patches = [(0, _PatchEvent.setIfMissing)(result.insert), this.props.value && this.props.value.length !== 0 ? (0, _PatchEvent.insert)(result.insert, 'after', result.path || focusPath) : (0, _PatchEvent.set)(result.insert, [])];
          onPatch(_PatchEvent.default.from(patches));
          onLoading({
            paste: null
          });
          return result.insert;
        }

        console.warn('Your onPaste function returned something unexpected:', result); // eslint-disable-line no-console

        return result;
      }).catch(error => {
        onLoading({
          paste: null
        });
        console.error(error); // eslint-disable-line no-console

        return error;
      });
    });

    _defineProperty(this, "handleCopy", (event, editor, next) => {
      if (_onCopy.default) {
        return (0, _onCopy.default)({
          event
        });
      }

      return next();
    });

    _defineProperty(this, "handleDrag", (event, editor, next) => {
      var transfer = (0, _slateReact.getEventTransfer)(event);
      var node = transfer.node;

      if (node && (node.object === 'block' || node.object === 'inline')) {
        event.dataTransfer.dropEffect = 'move';
        event.preventDefault();
        return true;
      }

      return next();
    });

    _defineProperty(this, "handleToggleFullscreen", (event, editor, next) => {
      var isFullscreenKey = (0, _isHotkey.isKeyHotkey)('mod+enter');
      var isEsc = (0, _isHotkey.isKeyHotkey)('esc');
      var _this$props3 = this.props,
          onToggleFullScreen = _this$props3.onToggleFullScreen,
          fullscreen = _this$props3.fullscreen;

      if (isFullscreenKey(event) || isEsc(event) && fullscreen) {
        event.preventDefault();
        event.stopPropagation();
        onToggleFullScreen(event);
        return true;
      }

      return next();
    });

    _defineProperty(this, "handleCancelEvent", event => {
      event.preventDefault();
      event.stopPropagation();
    });

    _defineProperty(this, "refBlockDragMarker", blockDragMarker => {
      this.blockDragMarker = blockDragMarker;
    });

    _defineProperty(this, "renderNode", props => {
      var _this$props4 = this.props,
          blockContentFeatures = _this$props4.blockContentFeatures,
          editorValue = _this$props4.editorValue,
          onFocus = _this$props4.onFocus,
          onPatch = _this$props4.onPatch,
          readOnly = _this$props4.readOnly,
          renderCustomMarkers = _this$props4.renderCustomMarkers,
          type = _this$props4.type,
          value = _this$props4.value;
      var node = props.node;
      var ObjectClass = _BlockObject.default;
      var ObjectType = blockContentFeatures.types.blockObjects.find(memberType => memberType.name === node.type);

      if (node.object === 'inline') {
        ObjectClass = _InlineObject.default;
        ObjectType = blockContentFeatures.types.inlineObjects.find(memberType => memberType.name === node.type);
      }

      var markers = [];

      if (node.object === 'inline') {
        markers = this.props.markers.filter(marker => marker.path[2] && (0, _getKey.getKey)(marker.path[2]) === node.data.get('_key'));
      }

      if (node.type === 'span') {
        markers = this.props.markers.filter(marker => marker.path[2] && (0, _getKey.getKey)(marker.path[2]) === node.data.get('_key')); // Add any markers for related markDefs here as well

        var annotations;

        if (annotations = node.data.get('annotations')) {
          var block = props.editor.value.document.getParent(node.key);
          Object.keys(annotations).forEach(key => {
            markers = markers.concat(this.props.markers.filter(marker => marker.path[0] && (0, _getKey.getKey)(marker.path[0]) === block.key && marker.path[1] && marker.path[1] === 'markDefs' && marker.path[2] && (0, _getKey.getKey)(marker.path[2]) === (0, _getKey.getKey)(annotations[key])));
          });
        }
      }

      switch (node.type) {
        case 'contentBlock':
          return _react.default.createElement(_ContentBlock.default, {
            attributes: props.attributes,
            block: value ? value.find(blk => blk._key === node.key) : (0, _blockTools.editorValueToBlocks)({
              document: {
                nodes: [node.toJSON(_createOperationToPatches.VALUE_TO_JSON_OPTS)]
              }
            }, type)[0],
            blockContentFeatures: blockContentFeatures,
            editor: props.editor,
            markers: markers,
            node: node,
            onFocus: onFocus,
            readOnly: readOnly,
            renderCustomMarkers: renderCustomMarkers
          }, props.children);

        case 'span':
          return _react.default.createElement(_Span.default, {
            attributes: props.attributes,
            blockContentFeatures: blockContentFeatures,
            editor: props.editor,
            markers: markers,
            node: props.node,
            onFocus: onFocus,
            onPatch: onPatch,
            readOnly: readOnly,
            type: blockContentFeatures.types.span
          }, props.children);

        default:
          return _react.default.createElement(ObjectClass, {
            attributes: props.attributes,
            blockContentFeatures: blockContentFeatures,
            editor: props.editor,
            editorValue: editorValue,
            isSelected: props.isFocused,
            markers: markers,
            node: props.node,
            onFocus: onFocus,
            onHideBlockDragMarker: this.handleHideBlockDragMarker,
            onPatch: onPatch,
            onShowBlockDragMarker: this.handleShowBlockDragMarker,
            readOnly: readOnly,
            renderCustomMarkers: renderCustomMarkers,
            type: ObjectType
          });
      }
    });

    _defineProperty(this, "renderMark", props => {
      var blockContentFeatures = this.props.blockContentFeatures;
      var type = props.mark.type;
      var decorator = blockContentFeatures.decorators.find(item => item.value === type);
      var CustomComponent = decorator && decorator.blockEditor && decorator.blockEditor.render ? decorator.blockEditor.render : null;

      if (CustomComponent) {
        return _react.default.createElement(CustomComponent, props);
      }

      return decorator ? _react.default.createElement(_Decorator.default, props) : null;
    });

    this.editorSchema = (0, _buildEditorSchema.default)(_props.blockContentFeatures);
    this.plugins = [(0, _QueryPlugin.default)(), (0, _ListItemOnEnterKeyPlugin.default)({
      defaultBlock: _blockTools.EDITOR_DEFAULT_BLOCK_TYPE
    }), (0, _ListItemOnTabKeyPlugin.default)(), (0, _ToggleListItemPlugin.default)(), (0, _TextBlockOnEnterKeyPlugin.default)({
      defaultBlock: _blockTools.EDITOR_DEFAULT_BLOCK_TYPE
    }), (0, _SetMarksOnKeyComboPlugin.default)({
      decorators: _props.blockContentFeatures.decorators.map(item => item.value)
    }), (0, _slateSoftBreak.default)({
      onlyIn: [_blockTools.EDITOR_DEFAULT_BLOCK_TYPE.type],
      shift: true
    }), (0, _PastePlugin.default)({
      controller: this.editor,
      blockContentType: _props.type,
      blockContentFeatures: _props.blockContentFeatures,
      onChange: _props.onChange,
      onProgress: this.handlePasteProgress
    }), (0, _slateInsertBlockOnEnter.default)(_blockTools.EDITOR_DEFAULT_BLOCK_TYPE), (0, _OnDropPlugin.default)(), (0, _OnFocusPlugin.default)(), (0, _TogglePlaceHolderPlugin.default)(), (0, _SetBlockStylePlugin.default)(), (0, _ToggleAnnotationPlugin.default)(), (0, _ExpandToWordPlugin.default)(), (0, _WrapSpanPlugin.default)(), (0, _InsertInlineObjectPlugin.default)(_props.type), (0, _InsertBlockObjectPlugin.default)(), (0, _EnsurePlaceHolderBlockPlugin.default)(_props.blockContentFeatures), (0, _UndoRedoPlugin.default)({
      stack: _props.undoRedoStack
    }), (0, _FirefoxVoidNodePlugin.default)(), (0, _FocusNoScrollPlugin.default)(_props.scrollContainer), (0, _ScrollAbsoluteTopBottomPlugin.default)(_props.scrollContainer), (0, _ScrollToFocusWithDynamicHeightPreviewPlugin.default)(_props.scrollContainer, scrollIntoView)];
  }

  componentDidMount() {
    this.trackFocusPath();
  }

  componentDidUpdate(prevProps) {
    var editor = this.getEditor();

    if (!editor) {
      return;
    } // Check if focusPAth has changed from what is currently the focus in the editor


    var focusPath = this.props.focusPath;

    if (!focusPath || focusPath.length === 0) {
      return;
    }

    var focusPathChanged = !(0, _isEqual2.default)(prevProps.focusPath, focusPath);

    if (!focusPathChanged) {
      return;
    }

    this.trackFocusPath();
  } // Select the editor document element according to the focusPath and scroll there
  // (unless it is a single block, then Slate will deal with it)
  // eslint-disable-next-line complexity


  trackFocusPath() {
    var _this$props5 = this.props,
        focusPath = _this$props5.focusPath,
        editorValue = _this$props5.editorValue;
    var editor = this.getEditor();

    if (!(editor && focusPath && editorValue)) {
      return;
    }

    var focusPathIsSingleBlock = editorValue.focusBlock && (0, _isEqual2.default)(focusPath, [{
      _key: editorValue.focusBlock.key
    }]);
    var firstKey = focusPath[0] && (0, _getKey.getKey)(focusPath[0]);
    var block = firstKey && editorValue.document.getDescendant(firstKey);
    var isRootVoidBlock = block && editor.query('isVoid', block);
    var inline; // Something inside a non-void root block is selected

    if (!focusPathIsSingleBlock && !isRootVoidBlock) {
      // Inline object
      var inlineKey = focusPath[2] && (0, _getKey.getKey)(focusPath[2]);
      inline = inlineKey && editorValue.document.getDescendant(inlineKey);

      if (inline && focusPath[1] && (focusPath[1] === 'children' || focusPath[1] === 'markDefs') && focusPath[2]) {
        scrollIntoView(inline);
      } // (void) Block
      else if (block) {
          scrollIntoView(block);
        }
    } // The rest should be handled by Slate

  } // When user changes the selection in the editor, update focusPath accordingly.


  render() {
    var _this$props6 = this.props,
        blockContentFeatures = _this$props6.blockContentFeatures,
        editorValue = _this$props6.editorValue,
        fullscreen = _this$props6.fullscreen,
        markers = _this$props6.markers,
        onFocus = _this$props6.onFocus,
        onPatch = _this$props6.onPatch,
        readOnly = _this$props6.readOnly,
        renderBlockActions = _this$props6.renderBlockActions,
        renderCustomMarkers = _this$props6.renderCustomMarkers,
        userIsWritingText = _this$props6.userIsWritingText,
        value = _this$props6.value;
    var hasMarkers = markers.filter(marker => marker.path.length > 0).length > 0;
    var classNames = [_Editor.default.root, (renderBlockActions || hasMarkers) && _Editor.default.hasBlockExtras, fullscreen ? _Editor.default.fullscreen : null].filter(Boolean);
    return _react.default.createElement("div", {
      className: classNames.join(' ')
    }, _react.default.createElement(_slateReact.Editor, {
      spellCheck: false,
      className: _Editor.default.editor,
      ref: this.editor,
      value: editorValue,
      onChange: this.handleChange,
      onFocus: this.handleEditorFocus,
      onCopy: this.handleCopy,
      onPaste: this.handlePaste,
      onKeyDown: this.handleToggleFullscreen,
      onDragOver: this.handleDrag,
      onDrop: this.handleDrag,
      plugins: this.plugins,
      readOnly: readOnly,
      renderNode: this.renderNode,
      renderMark: this.renderMark,
      schema: this.editorSchema
    }), _react.default.createElement("div", {
      className: _Editor.default.blockDragMarker,
      ref: this.refBlockDragMarker,
      style: {
        display: 'none'
      },
      onDragOver: this.handleCancelEvent
    }), _react.default.createElement("div", {
      className: _Editor.default.blockExtras
    }, _react.default.createElement(_BlockExtrasOverlay.default, {
      blockContentFeatures: blockContentFeatures,
      fullscreen: fullscreen,
      editor: this.editor,
      editorValue: editorValue,
      markers: markers,
      onFocus: onFocus,
      onPatch: onPatch,
      renderBlockActions: readOnly ? undefined : renderBlockActions,
      renderCustomMarkers: renderCustomMarkers,
      userIsWritingText: userIsWritingText,
      value: value
    })));
  }

}

exports.default = Editor;

_defineProperty(Editor, "defaultProps", {
  readOnly: false,
  onPaste: undefined,
  renderCustomMarkers: undefined,
  renderBlockActions: undefined
});