"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = SetBlockStylePlugin;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function SetBlockStylePlugin() {
  return {
    // eslint-disable-next-line complexity
    onCommand(command, editor, next) {
      if (command.type !== 'setBlockStyle') {
        return next();
      }

      var _editor$value = editor.value,
          selection = _editor$value.selection,
          startBlock = _editor$value.startBlock,
          endBlock = _editor$value.endBlock;
      var styleName = command.args[0]; // If a single block is selected partially, split block conditionally
      // (selection in start, middle or end of text)

      if (startBlock === endBlock && selection.isExpanded && !(selection.start.isAtStartOfNode(startBlock) && selection.end.isAtEndOfNode(startBlock))) {
        var hasTextBefore = !selection.start.isAtStartOfNode(startBlock);
        var hasTextAfter = !selection.end.isAtEndOfNode(startBlock);
        var move = selection.isForward ? selection.focus.offset - selection.anchor.offset : selection.anchor.offset - selection.focus.offset;

        if (hasTextAfter && !hasTextBefore) {
          editor.moveToStart().moveForward(move).moveToEnd().splitBlock().moveToStartOfPreviousText();
        } else if (hasTextBefore && !hasTextAfter) {
          editor.moveToEnd().moveBackward(move).moveToEnd().splitBlock().moveToEnd();
        } else {
          editor[selection.isForward ? 'moveToAnchor' : 'moveToFocus']().splitBlock().moveForward(move).splitBlock().moveToStartOfPreviousBlock();
        }
      } // Do the actual style transform, only acting on type contentBlock


      editor.value.blocks.forEach(blk => {
        var newData = _objectSpread({}, blk.data.toObject(), {
          style: styleName
        });

        if (blk.type === 'contentBlock') {
          editor.setNodeByKey(blk.key, {
            data: newData
          });
        }
      });
      return editor;
    }

  };
}