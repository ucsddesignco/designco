"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _slateReact = require("slate-react");

var _blockExtras = _interopRequireDefault(require("part:@sanity/form-builder/input/block-editor/block-extras"));

var _createBlockActionPatchFn = _interopRequireDefault(require("./utils/createBlockActionPatchFn"));

var _getKey = require("./utils/getKey");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; if (obj != null) { var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class BlockExtrasOverlay extends _react.default.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "_setVisibleTimer", void 0);

    _defineProperty(this, "_setVisibleRequest", void 0);

    _defineProperty(this, "state", {
      visible: false
    });

    _defineProperty(this, "renderBlockExtras", node => {
      var _this$props = this.props,
          blockContentFeatures = _this$props.blockContentFeatures,
          onFocus = _this$props.onFocus,
          renderCustomMarkers = _this$props.renderCustomMarkers,
          renderBlockActions = _this$props.renderBlockActions,
          onPatch = _this$props.onPatch,
          fullscreen = _this$props.fullscreen,
          editor = _this$props.editor;
      var markers = this.props.markers.filter(marker => marker.path[0] && (0, _getKey.getKey)(marker.path[0]) && (0, _getKey.getKey)(marker.path[0]) === node.key);

      if (markers.length === 0 && !renderBlockActions) {
        return null;
      }

      var element;

      try {
        element = (0, _slateReact.findDOMNode)(node); // eslint-disable-line react/no-find-dom-node
      } catch (err) {
        return null;
      }

      var rect = element.getBoundingClientRect();
      var actions = null;
      var value = this.props.value || [];

      if (renderBlockActions) {
        var block = value.find(blk => blk._key == node.key);
        var RenderComponent = renderBlockActions;

        if (block) {
          actions = _react.default.createElement(RenderComponent, {
            block: block,
            value: value,
            set: (0, _createBlockActionPatchFn.default)('set', block, onPatch, blockContentFeatures),
            unset: (0, _createBlockActionPatchFn.default)('unset', block, onPatch, blockContentFeatures),
            insert: (0, _createBlockActionPatchFn.default)('insert', block, onPatch, blockContentFeatures)
          });
        }
      }

      if (markers.length === 0 && !actions) {
        return null;
      }

      return _react.default.createElement("div", {
        key: node.key,
        style: {
          position: 'absolute',
          top: element.scrollTop + element.offsetTop,
          width: '100%',
          height: rect.height,
          left: 0
        }
      }, _react.default.createElement(_blockExtras.default, {
        block: node,
        fullscreen: fullscreen,
        blockActions: actions,
        editor: editor && editor.current,
        markers: markers,
        onFocus: onFocus,
        renderCustomMarkers: renderCustomMarkers
      }));
    });
  }

  componentDidMount() {
    // Wait for things to get finshed rendered before rendering the aboslute positions
    this._setVisibleTimer = setTimeout(() => {
      this._setVisibleRequest = window.requestAnimationFrame(() => {
        this.setState({
          visible: true
        });
        this._setVisibleTimer = setTimeout(() => {
          this.setState({
            visible: true
          });
        }, 200);
      });
    }, 0);
  }

  componentWillUnmount() {
    clearTimeout(this._setVisibleTimer);
    window.cancelAnimationFrame(this._setVisibleRequest);
  } // Don't update this while user is writing


  shouldComponentUpdate(nextProps) {
    return !nextProps.userIsWritingText;
  } // eslint-disable-next-line complexity


  render() {
    var visible = this.state.visible;
    var editorValue = this.props.editorValue;

    if (!visible || !editorValue) {
      return null;
    }

    return _react.default.createElement(_react.Fragment, null, editorValue.document.nodes.map(this.renderBlockExtras));
  }

}

exports.default = BlockExtrasOverlay;