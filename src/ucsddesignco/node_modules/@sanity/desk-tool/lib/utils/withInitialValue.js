"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(require("react"));

var _reactPropsStream = require("react-props-stream");

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _schema = _interopRequireDefault(require("part:@sanity/base/schema"));

var _preview = require("part:@sanity/base/preview");

var _draftUtils = require("part:@sanity/base/util/draft-utils");

var _ErrorPane = _interopRequireDefault(require("../pane/ErrorPane"));

var _LoadingPane = _interopRequireDefault(require("../pane/LoadingPane"));

var _BrokenReferences = _interopRequireDefault(require("../components/BrokenReferences"));

var _initialValueTemplates = require("@sanity/base/initial-value-templates");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var withInitialValue = Pane => (0, _reactPropsStream.streamingComponent)(props$ => props$.pipe((0, _operators.switchMap)(props => {
  var options = props.options; // See if the document ID has a draft or a published document

  return (0, _rxjs.merge)((0, _preview.observePaths)((0, _draftUtils.getDraftId)(options.id), ['_type']).pipe((0, _operators.map)(draft => ({
    draft
  }))), (0, _preview.observePaths)((0, _draftUtils.getPublishedId)(options.id), ['_type']).pipe((0, _operators.map)(published => ({
    published
  })))).pipe((0, _operators.scan)((prev, res) => _objectSpread({}, prev, {}, res), {}), // Wait until we know the state of both draft and published
  (0, _operators.filter)(res => 'draft' in res && 'published' in res), (0, _operators.map)(res => res.draft || res.published), // Only update if we didn't previously have a document but we now do
  (0, _operators.distinctUntilChanged)((prev, next) => Boolean(prev) !== Boolean(next)), (0, _operators.switchMap)(document => {
    var _getInitialValueProps = getInitialValueProps(document, props),
        templateName = _getInitialValueProps.templateName,
        parameters = _getInitialValueProps.parameters;

    var shouldResolve = Boolean(templateName);
    var documentType = options.type || document && document._type; // If we were not passed a schema type, use the resolved value if available

    var paneOptions = options.type ? options : _objectSpread({}, options, {
      type: documentType
    });

    if (!shouldResolve) {
      // Wrap in broken references component to prevent "reload"
      // when going from missing document to a document that exists
      return (0, _rxjs.of)(_react.default.createElement(_BrokenReferences.default, {
        document: {},
        type: documentType,
        schema: _schema.default
      }, _react.default.createElement(Pane, _extends({}, props, {
        options: paneOptions
      }))));
    }

    return (0, _rxjs.merge)((0, _rxjs.of)({
      isResolving: true
    }), resolveInitialValueWithParameters(templateName, parameters).pipe((0, _operators.catchError)(resolveError => {
      /* eslint-disable no-console */
      console.group('Failed to resolve initial value');
      console.error(resolveError);
      console.error('Template ID: %s', templateName);
      console.error('Parameters: %o', parameters || {});
      console.groupEnd();
      /* eslint-enable no-console */

      return (0, _rxjs.of)({
        resolveError
      });
    }))).pipe((0, _operators.switchMap)((_ref) => {
      var isResolving = _ref.isResolving,
          initialValue = _ref.initialValue,
          resolveError = _ref.resolveError;

      if (resolveError) {
        return (0, _rxjs.of)(_react.default.createElement(_ErrorPane.default, null, _react.default.createElement("h2", null, "Failed to resolve initial value"), _react.default.createElement("p", null, "Check developer console for details")));
      }

      var title = documentType && "New ".concat(_schema.default.get(documentType).title || documentType);
      return (0, _rxjs.of)(isResolving ? _react.default.createElement(_LoadingPane.default, _extends({}, props, {
        title: title,
        message: "Resolving initial value\u2026"
      })) : _react.default.createElement(_BrokenReferences.default, {
        document: initialValue,
        type: documentType,
        schema: _schema.default
      }, _react.default.createElement(Pane, _extends({}, props, {
        initialValue: initialValue,
        options: paneOptions
      }))));
    }));
  }));
})));

function getInitialValueProps(document, props) {
  if (document) {
    return {};
  }

  var definedTemplate = props.options.template;

  var _ref2 = props.urlParameters || {},
      urlTemplate = _ref2.template,
      urlParameters = _objectWithoutProperties(_ref2, ["template"]);

  if (urlTemplate && definedTemplate && definedTemplate !== urlTemplate) {
    // eslint-disable-next-line no-console
    console.warn("Conflicting templates: URL says \"".concat(urlParameters.template, "\", structure node says \"").concat(definedTemplate, "\". Using \"").concat(definedTemplate, "\"."));
  }

  var _props$options = props.options,
      options = _props$options === void 0 ? {} : _props$options;
  var template = options.template || urlTemplate;
  var typeTemplates = (0, _initialValueTemplates.getTemplatesBySchemaType)(options.type);

  var parameters = _objectSpread({}, options.templateParameters, {}, urlParameters);

  var templateName = template; // If we have not specified a specific template, and we only have a single
  // template available for a schema type, use it

  if (!template && typeTemplates.length === 1) {
    templateName = typeTemplates[0].id;
  }

  return {
    templateName,
    parameters
  };
}

function resolveInitialValueWithParameters(templateName, parameters) {
  if (!(0, _initialValueTemplates.templateExists)(templateName)) {
    // eslint-disable-next-line no-console
    console.warn('Template "%s" not defined, using empty initial value', templateName);
    return (0, _rxjs.of)({
      isResolving: false,
      initialValue: undefined
    });
  }

  return (0, _rxjs.from)((0, _initialValueTemplates.resolveInitialValue)((0, _initialValueTemplates.getTemplateById)(templateName), parameters)).pipe((0, _operators.map)(initialValue => ({
    isResolving: false,
    initialValue
  })));
}

var _default = withInitialValue;
exports.default = _default;