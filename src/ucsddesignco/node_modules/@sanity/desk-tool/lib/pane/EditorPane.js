"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _debounce2 = _interopRequireDefault(require("lodash/debounce"));

var _throttle2 = _interopRequireDefault(require("lodash/throttle"));

var _omit2 = _interopRequireDefault(require("lodash/omit"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _promiseLatest = _interopRequireDefault(require("promise-latest"));

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _validation = require("@sanity/validation");

var _formBuilder = require("part:@sanity/form-builder");

var _draftUtils = require("part:@sanity/base/util/draft-utils");

var _schema = _interopRequireDefault(require("part:@sanity/base/schema"));

var _default2 = _interopRequireDefault(require("part:@sanity/components/buttons/default"));

var _history = _interopRequireDefault(require("part:@sanity/base/datastore/history"));

var _client = _interopRequireDefault(require("part:@sanity/base/client"));

var _EditorWrapper = _interopRequireDefault(require("./styles/EditorWrapper.css"));

var _Editor = _interopRequireDefault(require("./Editor"));

var _UseState = _interopRequireDefault(require("../utils/UseState"));

var _withInitialValue = _interopRequireDefault(require("../utils/withInitialValue"));

var _class, _temp;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var INITIAL_DOCUMENT_STATE = {
  isLoading: true,
  deletedSnapshot: null,
  snapshot: null
};
var INITIAL_STATE = {
  isSaving: true,
  isReconnecting: false,
  isRestoring: false,
  isCreatingDraft: false,
  transactionResult: null,
  validationPending: true,
  draft: INITIAL_DOCUMENT_STATE,
  published: INITIAL_DOCUMENT_STATE
};

function documentEventToState(event) {
  switch (event.type) {
    case 'rebase':
    case 'create':
    case 'createIfNotExists':
    case 'snapshot':
      {
        return {
          deletedSnapshot: null,
          snapshot: event.document
        };
      }

    case 'mutation':
      {
        return {
          deletedSnapshot: event.deletedSnapshot,
          snapshot: event.document ? _objectSpread({}, event.document, {
            // todo: The following line is a temporary workaround for a problem with the mutator not
            // setting updatedAt on patches applied optimistic when they are received from server
            // can be removed when this is fixed
            _updatedAt: new Date().toISOString()
          }) : event.document
        };
      }

    case 'reconnect':
      {
        return {};
      }

    case 'committed':
      {
        // note: we *could* use this in conjunction with <document>.commit()
        // by setting this.state.isSaving=true before calling <document>.commit and setting to false
        // again when we get the 'committed' event back.
        // However, calling <document>.commit() doesn't necessarily result in a commit actually being done,
        // and thus we are not guaranteed to get a 'committed' event back after a call to
        // <document>.commit(), which means we could easily get into a situation where the
        // `isSaving` state stays around forever.
        return {};
      }

    case 'error':
      {
        return {};
      }

    default:
      {
        // eslint-disable-next-line no-console
        console.log('Unhandled document event type "%s"', event.type, event);
        return {};
      }
  }
}

function exists(draft, published) {
  return draft.snapshot || published.snapshot;
}

function isRecoverable(draft, published) {
  return !exists(draft, published) && (draft.deletedSnapshot || published.deletedSnapshot);
}

var _default = (0, _withInitialValue.default)((_temp = _class = class EditorPane extends _react.default.Component {
  constructor(props) {
    var _this;

    super(props);
    _this = this;

    _defineProperty(this, "state", INITIAL_STATE);

    _defineProperty(this, "patchChannel", _formBuilder.FormBuilder.createPatchChannel());

    _defineProperty(this, "validateDocument",
    /*#__PURE__*/
    _asyncToGenerator(function* () {
      var _this$state = _this.state,
          draft = _this$state.draft,
          published = _this$state.published;
      var doc = draft && draft.snapshot || published && published.snapshot;

      if (!doc || !doc._type) {
        return [];
      }

      var type = _schema.default.get(doc._type);

      if (!type) {
        // eslint-disable-next-line no-console
        console.warn('Schema for document type "%s" not found, skipping validation');
        return [];
      }

      var markers = yield (0, _validation.validateDocument)(doc, _schema.default);

      _this.setStateIfMounted({
        markers,
        validationPending: false
      });

      return markers;
    }));

    _defineProperty(this, "receiveDraftEvent", event => {
      if (event.type !== 'mutation') {
        return;
      } // Broadcast incoming patches to input components that applies patches on their own
      // Note: This is *experimental*


      this.patchChannel.receivePatches({
        patches: event.patches,
        snapshot: event.document
      });
    });

    _defineProperty(this, "handleDelete", () => {
      var documentId = this.props.options.id;

      var tx = _client.default.observable.transaction().delete((0, _draftUtils.getPublishedId)(documentId)).delete((0, _draftUtils.getDraftId)(documentId));

      tx.commit().pipe((0, _operators.map)(result => ({
        type: 'success',
        result: result
      })), (0, _operators.catchError)(error => (0, _rxjs.of)({
        type: 'error',
        message: "An error occurred while attempting to delete document.\n              This usually means that you attempted to delete a document that other documents\n              refers to.",
        error
      }))).subscribe(result => {
        this.setStateIfMounted({
          transactionResult: result
        });
      });
    });

    _defineProperty(this, "handleClearTransactionResult", () => {
      this.setStateIfMounted({
        transactionResult: null
      });
    });

    _defineProperty(this, "handleUnpublish", () => {
      var documentId = this.props.options.id;
      var published = this.state.published;

      var tx = _client.default.observable.transaction().delete((0, _draftUtils.getPublishedId)(documentId));

      if (published.snapshot) {
        tx = tx.createIfNotExists(_objectSpread({}, (0, _omit2.default)(published.snapshot, '_updatedAt'), {
          _id: (0, _draftUtils.getDraftId)(documentId)
        }));
      }

      tx.commit().pipe((0, _operators.map)(result => ({
        type: 'success',
        result: result
      })), (0, _operators.catchError)(error => (0, _rxjs.of)({
        type: 'error',
        message: "An error occurred while attempting to unpublish document.\n        This usually means that you attempted to unpublish a document that other documents\n        refers to.",
        error
      }))).subscribe(result => {
        this.setStateIfMounted({
          transactionResult: result
        });
      });
    });

    _defineProperty(this, "handlePublish", () => {
      var documentId = this.props.options.id;
      var _this$state2 = this.state,
          draft = _this$state2.draft,
          published = _this$state2.published;
      this.setState({
        isPublishing: true
      });

      var tx = _client.default.observable.transaction();

      if (!published || !published.snapshot) {
        // If the document has not been published, we want to create it - if it suddenly exists
        // before being created, we don't want to overwrite if, instead we want to yield an error
        tx.create(_objectSpread({}, (0, _omit2.default)(draft.snapshot, '_updatedAt'), {
          _id: (0, _draftUtils.getPublishedId)(documentId)
        }));
      } else {
        // If it exists already, we only want to update it if the revision on the remote server
        // matches what our local state thinks it's at
        tx.patch((0, _draftUtils.getPublishedId)(documentId), {
          // Hack until other mutations support revision locking
          unset: ['_reserved_prop_'],
          ifRevisionID: published.snapshot._rev
        }).createOrReplace(_objectSpread({}, (0, _omit2.default)(draft.snapshot, '_updatedAt'), {
          _id: (0, _draftUtils.getPublishedId)(documentId)
        }));
      }

      tx.delete((0, _draftUtils.getDraftId)(documentId)); // @todo add error handling for revision mismatch

      tx.commit().pipe((0, _operators.map)(result => ({
        type: 'success',
        result: result
      })), (0, _operators.catchError)(error => (0, _rxjs.of)({
        type: 'error',
        message: 'An error occurred while attempting to publishing document',
        error
      }))).subscribe({
        next: result => {
          this.setState({
            transactionResult: result
          });
        },
        complete: () => {
          this.setStateIfMounted({
            isPublishing: false
          });
        }
      });
    });

    _defineProperty(this, "handleRestoreRevision", (_ref2) => {
      var id = _ref2.id,
          rev = _ref2.rev;

      var transactionResult$ = _history.default.restore(id, rev).pipe((0, _operators.map)(result => ({
        type: 'success',
        result: result
      })), (0, _operators.catchError)(error => (0, _rxjs.of)({
        type: 'error',
        message: 'An error occurred while attempting to restore the document',
        error
      })), (0, _operators.map)(transactionResult => ({
        transactionResult
      })));

      (0, _rxjs.concat)((0, _rxjs.of)({
        isRestoring: true
      }), transactionResult$, (0, _rxjs.of)({
        isRestoring: false
      })).subscribe(nextState => {
        this.setStateIfMounted(nextState);
      });
    });

    _defineProperty(this, "handleChange", event => {
      var _this$state3 = this.state,
          published = _this$state3.published,
          draft = _this$state3.draft;
      var initialValue = this.getInitialValue();

      if (this.isLiveEditEnabled()) {
        // No drafting, patch and commit the published document
        this.published.createIfNotExists(_objectSpread({
          _id: this.getPublishedId()
        }, initialValue));
        this.published.patch(event.patches);
      } else {
        if (!draft.snapshot) {
          this.draft.createIfNotExists(_objectSpread({}, (0, _omit2.default)(published.snapshot, '_updatedAt'), {
            _id: this.getDraftId()
          }, initialValue));
        }

        this.draft.patch(event.patches);
      }

      this.commit();
    });

    _defineProperty(this, "setStateIfMounted", function () {
      if (!_this._isMounted) {
        return;
      }

      _this.setState(...arguments);
    });

    _defineProperty(this, "commit", (0, _throttle2.default)(() => {
      var currentDoc = this.isLiveEditEnabled() ? this.published : this.draft;
      this.setStateIfMounted({
        isSaving: true
      });
      currentDoc.commit().subscribe({
        next: () => {// todo
        },
        error: _error => {// todo
        },
        complete: () => {
          this.setStateIfMounted({
            isSaving: false
          });
        }
      });
    }, 1000, {
      leading: true,
      trailing: true
    }));

    _defineProperty(this, "handleRestoreDeleted", () => {
      var _this$state4 = this.state,
          draft = _this$state4.draft,
          published = _this$state4.published;
      var commits = [];

      if (draft.deletedSnapshot) {
        this.draft.createIfNotExists(draft.deletedSnapshot);
        commits.push(this.draft.commit());
      } else if (published.deletedSnapshot) {
        this.published.createIfNotExists(published.deletedSnapshot);
        commits.push(this.published.commit());
      }

      commits.forEach(c => {
        c.subscribe({
          next: () => {}
        });
      });
    });

    this.setup(props.options.id);
  }

  setup(documentId) {
    this.dispose();
    var publishedId = (0, _draftUtils.getPublishedId)(documentId);
    var draftId = (0, _draftUtils.getDraftId)(documentId);

    var _checkoutPair = (0, _formBuilder.checkoutPair)({
      publishedId,
      draftId
    }),
        published = _checkoutPair.published,
        draft = _checkoutPair.draft;

    this.published = published;
    this.draft = draft;
    this.validateLatestDocument = (0, _debounce2.default)((0, _promiseLatest.default)(this.validateDocument, 300));
    var published$ = this.published.events;
    var draft$ = this.draft.events.pipe((0, _operators.tap)(this.receiveDraftEvent));
    this.subscription = (0, _rxjs.merge)(published$.pipe((0, _operators.map)(event => _objectSpread({}, event, {
      version: 'published'
    }))), draft$.pipe((0, _operators.map)(event => _objectSpread({}, event, {
      version: 'draft'
    })))).pipe((0, _operators.switchMap)(event => event.type === 'reconnect' ? (0, _rxjs.timer)(500).pipe((0, _operators.mapTo)(event)) : (0, _rxjs.of)(event)), (0, _operators.catchError)((err, _caught$) => {
      // eslint-disable-next-line no-console
      console.error(err);
      return (0, _rxjs.of)({
        type: 'error',
        error: err
      });
    })).subscribe(event => {
      this.setState(prevState => {
        var version = event.version; // either 'draft' or 'published'

        return {
          isReconnecting: event.type === 'reconnect',
          validationPending: true,
          error: event.type === 'error' ? event.error : null,
          [version]: _objectSpread({}, prevState[version] || {}, {}, documentEventToState(event), {
            isLoading: false
          })
        };
      }, this.validateLatestDocument);
    });
  }

  getDraftId() {
    return (0, _draftUtils.getDraftId)(this.props.options.id);
  }

  getPublishedId() {
    return (0, _draftUtils.getPublishedId)(this.props.options.id);
  }

  componentDidUpdate(prevProps) {
    if (prevProps.options.id !== this.props.options.id) {
      this.setup(this.props.options.id);
    }
  }

  componentDidMount() {
    this._isMounted = true;
  }

  componentWillUnmount() {
    this._isMounted = false; // Cancel throttled commit since draft will be nulled on unmount

    this.commit.cancel(); // Instead, explicitly commit

    this.draft.commit().subscribe(() => {// todo: error handling
    });
    this.dispose();
  }

  isLiveEditEnabled() {
    var selectedSchemaType = _schema.default.get(this.props.options.type);

    return selectedSchemaType.liveEdit === true;
  }

  dispose() {
    if (this.subscription) {
      this.subscription.unsubscribe();
      this.subscription = null;
    }

    if (this.validateLatestDocument) {
      this.validateLatestDocument.cancel();
      this.validateLatestDocument = null;
    }

    this.published = null;
    this.draft = null;
  }

  renderDeleted() {
    return _react.default.createElement("div", {
      className: _EditorWrapper.default.deletedDocument
    }, _react.default.createElement("div", {
      className: _EditorWrapper.default.deletedDocumentInner
    }, _react.default.createElement("h3", null, "This document just got deleted"), _react.default.createElement("p", null, "You can undo deleting it until you close this window/tab"), _react.default.createElement(_default2.default, {
      onClick: this.handleRestoreDeleted
    }, "Undo delete")));
  }

  renderError(error) {
    return _react.default.createElement("div", {
      className: _EditorWrapper.default.error
    }, _react.default.createElement("div", {
      className: _EditorWrapper.default.errorInner
    }, _react.default.createElement("h3", null, "We\u2019re sorry, but your changes could not be applied."), _react.default.createElement(_UseState.default, {
      startWith: false
    }, (_ref3) => {
      var _ref4 = _slicedToArray(_ref3, 2),
          isExpanded = _ref4[0],
          setExpanded = _ref4[1];

      return _react.default.createElement(_react.default.Fragment, null, _react.default.createElement(_default2.default, {
        onClick: () => this.setup(this.props.options.id)
      }, "Reload"), _react.default.createElement(_default2.default, {
        inverted: true,
        onClick: () => setExpanded(!isExpanded)
      }, isExpanded ? 'Hide' : 'Show', " details"), _react.default.createElement("div", null, isExpanded && _react.default.createElement("textarea", {
        className: _EditorWrapper.default.errorDetails,
        onFocus: e => e.currentTarget.select(),
        value: error.stack
      })));
    })));
  }

  renderUnknownSchemaType() {
    var options = this.props.options;
    var _this$state5 = this.state,
        draft = _this$state5.draft,
        published = _this$state5.published;
    var typeName = options.type;
    var doc = draft.snapshot || published.snapshot;
    return _react.default.createElement("div", {
      className: _EditorWrapper.default.unknownSchemaType
    }, _react.default.createElement("div", {
      className: _EditorWrapper.default.unknownSchemaTypeInner
    }, _react.default.createElement("h3", null, "Unknown schema type"), _react.default.createElement("p", null, "This document has the schema type ", _react.default.createElement("code", null, typeName), ", which is not defined as a type in the local content studio schema."), __DEV__ && doc && _react.default.createElement("div", null, _react.default.createElement("h4", null, "Here is the JSON representation of the document:"), _react.default.createElement("pre", {
      className: _EditorWrapper.default.jsonDump
    }, _react.default.createElement("code", null, JSON.stringify(doc, null, 2))))));
  }

  getInitialValue() {
    var _this$state6 = this.state,
        draft = _this$state6.draft,
        published = _this$state6.published;
    var typeName = this.props.options.type;
    var base = {
      _type: typeName
    };
    return exists(draft, published) ? base : _objectSpread({}, base, {}, this.props.initialValue);
  }

  render() {
    var initialValue = this.getInitialValue();
    var _this$props = this.props,
        options = _this$props.options,
        index = _this$props.index,
        title = _this$props.title;
    var typeName = options.type;

    var schemaType = _schema.default.get(typeName);

    var _this$state7 = this.state,
        draft = _this$state7.draft,
        published = _this$state7.published,
        markers = _this$state7.markers,
        isCreatingDraft = _this$state7.isCreatingDraft,
        isUnpublishing = _this$state7.isUnpublishing,
        transactionResult = _this$state7.transactionResult,
        isPublishing = _this$state7.isPublishing,
        isRestoring = _this$state7.isRestoring,
        isSaving = _this$state7.isSaving,
        error = _this$state7.error,
        validationPending = _this$state7.validationPending,
        isReconnecting = _this$state7.isReconnecting;

    if (!schemaType) {
      return this.renderUnknownSchemaType();
    }

    if (isRecoverable(draft, published)) {
      return this.renderDeleted();
    }

    if (error) {
      return this.renderError(error);
    }

    return _react.default.createElement(_Editor.default, {
      title: title,
      paneIndex: index,
      patchChannel: this.patchChannel,
      type: schemaType,
      published: published.snapshot,
      draft: draft.snapshot,
      markers: markers,
      initialValue: initialValue,
      validationPending: validationPending,
      isLoading: draft.isLoading || published.isLoading,
      isRestoring: isRestoring,
      isSaving: isSaving,
      isReconnecting: isReconnecting,
      isPublishing: isPublishing,
      isUnpublishing: isUnpublishing,
      transactionResult: transactionResult,
      isCreatingDraft: isCreatingDraft,
      onDelete: this.handleDelete,
      onClearTransactionResult: this.handleClearTransactionResult,
      onPublish: this.handlePublish,
      onRestore: this.handleRestoreRevision,
      onUnpublish: this.handleUnpublish,
      onChange: this.handleChange
    });
  }

}, _defineProperty(_class, "propTypes", {
  title: _propTypes.default.string,
  index: _propTypes.default.number.isRequired,
  initialValue: _propTypes.default.object,
  // eslint-disable-line react/forbid-prop-types
  options: _propTypes.default.shape({
    id: _propTypes.default.string.isRequired,
    type: _propTypes.default.string.isRequired,
    template: _propTypes.default.string
  }).isRequired
}), _defineProperty(_class, "defaultProps", {
  title: null,
  initialValue: undefined
}), _temp));

exports.default = _default;