"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createPatchesToChange;

var _isString2 = _interopRequireDefault(require("lodash/isString"));

var _isEqual2 = _interopRequireDefault(require("lodash/isEqual"));

var _slate = require("slate");

var _simplePatch = _interopRequireWildcard(require("../../../simplePatch"));

var _findInlineByAnnotationKey = _interopRequireDefault(require("./findInlineByAnnotationKey"));

var _createSelectionOperation = _interopRequireDefault(require("./createSelectionOperation"));

var _createEditorController = _interopRequireDefault(require("./createEditorController"));

var _buildEditorSchema = _interopRequireDefault(require("./buildEditorSchema"));

var _createEmptyBlock = _interopRequireDefault(require("./createEmptyBlock"));

var _blockTools = require("@sanity/block-tools");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; if (obj != null) { var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var isKeyedSegment = segment => {
  return typeof segment === 'object' && '_key' in segment;
}; // Helper function to find the last part of a patch path that has a known key


function findLastKey(path) {
  var key = null;
  path.forEach(part => {
    if (isKeyedSegment(part)) {
      key = part._key;
    }
  });
  return key;
} // Helper function to find a Slate Text node from a patch path key


function findTextNodeFromPathKey(blockNode, pathKey) {
  if (!blockNode) {
    throw new Error('No blockNode given!');
  }

  var count = -1;
  var targetIndex = blockNode.nodes.findIndex(node => {
    if (node.object === 'text') {
      for (var i = 0; i < node.leaves.size; i++) {
        count++; // eslint-disable-next-line max-depth

        if ("".concat(blockNode.key).concat(count) === pathKey) {
          break;
        }
      }
    } else {
      count++;
    }

    return "".concat(blockNode.key).concat(count) === pathKey;
  });
  return blockNode.nodes.get(targetIndex);
} // Helper function to find the last known node to the editor inside a patch path


function findLastKnownEditorNodeInPath(block, patchPath) {
  var node = null;
  var pIndex = patchPath.length - 1;

  while (node === null && pIndex >= 0) {
    var key = patchPath[pIndex]._key;

    if (key) {
      node = block.getDescendant(key) || null;
    }

    pIndex--;
  }

  return node;
}

function getBlockTextIndex(blockNode, childNode) {
  var positionCount = -1;
  blockNode.nodes.some(cNode => {
    if (cNode.key === childNode.key) {
      positionCount++;
      return true;
    }

    if (cNode.object === 'text') {
      positionCount += cNode.leaves.size;
    } else {
      positionCount++;
    }

    return false;
  });
  return positionCount;
}

function createPatchesToChange(blockContentFeatures, blockContentType) {
  var schema = (0, _buildEditorSchema.default)(blockContentFeatures, {
    withNormalization: false
  });
  var controller = (0, _createEditorController.default)({
    value: null,
    plugins: [{
      schema
    }]
  });

  function setPatch(patch, editor) {
    if (Array.isArray(patch.value)) {
      if (patch.path.length === 0) {
        return replaceValue(patch.value, editor);
      }

      throw new Error("Invalid patch, looks like it should be an insert: ".concat(JSON.stringify(patch)));
    }

    var editorBlock = (0, _blockTools.blocksToEditorValue)([patch.value], blockContentType).document.nodes[0];
    var key = findLastKey(patch.path);
    editor.replaceNodeByKey(key, editorBlock);
    return editor.operations;
  }

  function setIfMissingPatch(patch, editor) {
    if (patch.path.length === 0) {
      if (editor.value.document.nodes.size === 0) {
        return replaceValue(patch.value, editor);
      }

      return editor.operations;
    }

    var doc = editor.value.document;
    var blockKey = patch.path[0]._key;
    var block = doc.nodes.find(node => node.key === blockKey);

    if (editor.query('isVoid', block)) {
      var data = block.data.toObject();

      if (!data.value) {
        var newData = _objectSpread({}, data, {
          value: patch.value
        });

        editor.setNodeByKey(blockKey, {
          data: newData
        });
      }
    }

    return editor.operations;
  }

  function insertPatch(patch, editor) {
    var items = patch.items,
        position = patch.position;
    var blocksToInsert = (0, _blockTools.blocksToEditorValue)(items, blockContentType);
    var posKey = findLastKey(patch.path);
    var index = editor.value.document.nodes.findIndex((node, indx) => {
      return posKey ? node.key === posKey : indx === patch.path[0];
    });

    if (position === 'before') {
      index = index > 0 ? index-- : index;
    }

    if (position === 'after') {
      index++;
    }

    blocksToInsert.document.nodes.forEach(block => {
      editor.applyOperation({
        type: 'insert_node',
        path: [index++],
        node: block
      });
    });
    return editor.operations;
  }

  function unsetPatch(patch, editor) {
    // Deal with patches unsetting the whole field
    if (patch.path.length === 0) {
      editor.value.document.nodes.forEach(node => {
        editor.applyOperation({
          type: 'remove_node',
          path: [0],
          node: node
        });
      }); // Create a placeholder block and set focus

      var block = (0, _createEmptyBlock.default)(blockContentFeatures);
      var node = block.toJSON({
        preserveKeys: true,
        preserveData: true
      });
      node.data = _objectSpread({}, node.data, {
        placeholder: true
      });
      editor.applyOperation({
        type: 'insert_node',
        path: [0],
        node: node
      });
      editor.focus();
      return editor.operations;
    } // Deal with patches unsetting something inside


    var lastKey = findLastKey(patch.path);
    var editorNode = editor.value.document.getDescendant(lastKey);
    var isDirectlyTargeted = patch.path.findIndex(part => part._key && part._key === lastKey) === patch.path.length - 1; // If it is targeting a node in our document directly, just remove that node

    if (isDirectlyTargeted && lastKey && editorNode) {
      editor.removeNodeByKey(lastKey);
    } // If it is targeting a data value inside some node's data,
    // patch that data value and update the containing node


    if (!isDirectlyTargeted && lastKey && editorNode) {
      var data = editorNode.data.toObject();

      var _patch = _objectSpread({}, patch, {
        path: patch.path.slice(patch.path.indexOf({
          _key: lastKey
        }))
      });

      var newValue = data.value ? (0, _simplePatch.applyAll)(data.value, [_patch]) : data.value;
      data.value = newValue;
      editor.setNodeByKey(editorNode.key, {
        data
      });
    }

    return editor.operations;
  }

  function replaceValue(snapshot, editor) {
    // console.log('Replacing value')
    if (snapshot) {
      var fragment = (0, _blockTools.blocksToEditorValue)(snapshot, blockContentType); // Store the old selection

      var select = (0, _createSelectionOperation.default)(editor);
      editor.value.document.nodes.forEach(node => {
        editor.applyOperation({
          type: 'remove_node',
          path: [0],
          node: node
        });
      });
      fragment.document.nodes.reverse().forEach(node => {
        editor.applyOperation({
          type: 'insert_node',
          path: [0],
          node: node
        });
      }); // Restore the old selection

      editor.applyOperation(select);
      return editor.operations;
    }

    throw new Error('No snapshot given!');
  } // eslint-disable-next-line complexity


  function patchAnnotationData(patch, editor) {
    var doc = editor.value.document;
    var markDefKey = patch.path[2]._key;
    var node = (0, _findInlineByAnnotationKey.default)(markDefKey, doc);
    var data = node.data.toObject();
    data.annotations = data.annotations || {};
    var annotationKey = Object.keys(data.annotations).find(key => data.annotations[key]._key === markDefKey);

    if (!annotationKey) {
      throw new Error('Annotation not found in data');
    } // If this is a unset patch, remove the annotation


    if (patch.type === 'unset' && patch.path.length === 3) {
      delete data.annotations[annotationKey]; // If no more annotations, unwrap the inline

      if (Object.keys(data.annotations).length === 0) {
        editor.unwrapInlineByKey(node.key);
        return editor.operations;
      }

      editor.setNodeByKey(node.key, {
        data
      });
      return editor.operations;
    }

    var _patch = _objectSpread({}, patch);

    _patch.path = patch.path.slice(2);
    var annotation = data.annotations[annotationKey];
    data.annotations[annotationKey] = (0, _simplePatch.applyAll)([annotation], [_patch])[0];
    editor.setNodeByKey(node.key, {
      data
    });
    return editor.operations;
  }

  function patchVoidBlockData(patch, editor) {
    var doc = editor.value.document;
    var blockKey = patch.path[0]._key;
    var block = doc.nodes.find(node => node.key === blockKey); // Only act on void formBuilder blocks

    if (editor.query('isVoid', block)) {
      var data = block.data.toObject();

      var _patch = _objectSpread({}, patch);

      _patch.path = _patch.path.slice(1);
      var newValue = (0, _simplePatch.applyAll)(data.value, [_patch]);
      data.value = newValue;
      editor.setNodeByKey(block.key, {
        data
      });
    }

    return editor.operations;
  }

  function patchInlineData(patch, editor, inline) {
    var data = inline.data.toObject();

    var _patch = _objectSpread({}, patch);

    _patch.path = _patch.path.slice(3);
    var newValue = (0, _simplePatch.applyAll)(data.value, [_patch]);
    data.value = newValue;
    editor.setNodeByKey(inline.key, {
      data
    });
    return editor.operations;
  }

  function rebasePatch(patch, editor) {
    if (!editor.value.selection.isFocused || !Array.isArray(patch.value) || patch.value.length === 0) {
      return replaceValue(patch.value, editor);
    } // We must modify the selection' paths!


    var focusBlockKey = editor.value.focusBlock.key;
    var anchorBlockKey = editor.value.anchorBlock.key;
    var focusPath = editor.value.document.assertPath(focusBlockKey);
    var anchorPath = editor.value.document.assertPath(anchorBlockKey);
    var oldFocusBlockIndex = focusPath.get(0);
    var oldAnchorBlockIndex = anchorPath.get(0);
    var newFocusBlockIndex = patch.value.findIndex(blk => blk._key === focusBlockKey);
    var newAnchorBlockIndex = patch.value.findIndex(blk => blk._key === anchorBlockKey);

    if (newFocusBlockIndex !== oldFocusBlockIndex || newAnchorBlockIndex !== oldAnchorBlockIndex) {
      // console.log('Modifying selection and replacing value')
      var selection = editor.value.selection.toJSON();
      selection.anchor.path = [newAnchorBlockIndex, ...selection.anchor.path.slice(1)];
      selection.focus.path = [newFocusBlockIndex, ...selection.focus.path.slice(1)];
      replaceValue(patch.value, editor);
      editor.select(_slate.Selection.fromJSON(selection));
      return editor.operations;
    } // console.log('Replacing value because rebase')


    return replaceValue(patch.value, editor);
  } // eslint-disable-next-line complexity


  function patchSpanText(patch, editor, node, blockNode) {
    var blockKey = patch.path[0]._key;
    var childKey = findLastKey(patch.path);
    var textNode = node.getFirstText();
    var textPath = editor.value.document.assertPath(textNode.key);
    var workTextNode = textNode.toJSON({
      preserveKeys: true
    });
    var blockIndex = getBlockTextIndex(blockNode, node);
    var leafIndex = workTextNode.leaves.findIndex((leaf, index) => "".concat(blockKey).concat(blockIndex + index) === childKey); // Insert patches for new spans

    if (patch.type === 'insert') {
      var targetIndex = leafIndex;

      if (patch.position === 'before') {
        targetIndex--;
      }

      var newLeaves = [];
      workTextNode.leaves.forEach((leaf, index) => {
        if (targetIndex === index) {
          newLeaves.push(leaf);
          patch.items.forEach(item => {
            var newLeaf = {
              text: item.text,
              marks: _slate.Mark.createSet(item.marks.map(mark => ({
                type: mark
              })))
            };
            newLeaves.push(newLeaf);
          });
        } else {
          newLeaves.push(leaf);
        }
      });
      workTextNode.leaves = newLeaves; // Replace it

      editor.replaceNodeByPath(textPath, _slate.Text.fromJSON(workTextNode));
      return editor.operations;
    } // Set patches patching either string values or span objects


    if (patch.type === 'set') {
      var valueIsString = (0, _isString2.default)(patch.value);
      var patchText = valueIsString ? patch.value : patch.value.text; // If single leaf, we can just replace the text with the current marks

      if (textNode.leaves.size === 1) {
        var marks; // eslint-disable-next-line max-depth

        if (valueIsString) {
          marks = textNode.leaves.map(leaf => leaf.marks).get(0);
        } else {
          marks = _slate.Mark.createSet(patch.value.marks.map(mark => ({
            type: mark
          })));
        }

        editor.replaceNodeByPath(textPath, _slate.Text.create({
          text: patchText,
          marks
        }));
        return editor.operations;
      } // Build the new text


      workTextNode.leaves[leafIndex] = {
        object: 'leaf',
        text: patchText,
        marks: valueIsString ? node.leaves.get(leafIndex).marks : _slate.Mark.createSet(patch.value.marks.map(mark => ({
          type: mark
        })))
      }; // Replace it

      editor.replaceNodeByPath(textPath, _slate.Text.fromJSON(workTextNode));
      return editor.operations;
    } // DiffMatch patches for existing spans text value


    if (patch.type === 'diffMatchPatch') {
      var _marks = workTextNode.leaves[leafIndex].marks;
      workTextNode.leaves[leafIndex] = {
        object: 'leaf',
        text: (0, _simplePatch.default)(workTextNode.leaves[leafIndex].text, _objectSpread({}, patch, {
          path: []
        })),
        marks: _marks
      }; // Replace it

      editor.replaceNodeByPath(textPath, _slate.Text.fromJSON(workTextNode));
      return editor.operations;
    }

    throw new Error("Don't know how to handle unknown patch type here");
  } // eslint-disable-next-line complexity


  return function patchToOperations(patch, editorValue) {
    controller.flush(); // Must flush here or we end up with duplicate operations

    controller.setValue(editorValue);

    if (patch.origin === 'internal' && patch.type === 'set' && (0, _isEqual2.default)(patch.path, [])) {
      return rebasePatch(patch, controller);
    }

    var firstKey = patch.path[0] && patch.path[0]._key;
    var decendant = firstKey && editorValue.document.getDescendant(firstKey);
    var isVoidRootBlock = decendant && editorValue && editorValue.document && editorValue.document.size > 0 && controller.query('isVoid', decendant);
    var rootBlock = firstKey && editorValue.document.getDescendant(firstKey);
    var isContentBlockChildrenPatches = !isVoidRootBlock && patch.path[1] === 'children' && patch.path.length >= 3;
    var isMarkDefPatches = !isVoidRootBlock && patch.path[1] === 'markDefs'; // Patches working inside blocks needs to be treated a bit special,
    // because Slate's model diversity

    if (patch.path.length > 1) {
      if (isMarkDefPatches) {
        // Annotations are a bit special because they come from .markDefs on the block root
        return patchAnnotationData(patch, controller);
      } else if (isContentBlockChildrenPatches) {
        // If it is a unset patch, just remove the node normally and return
        // eslint-disable-next-line max-depth
        if (patch.type === 'unset') {
          return unsetPatch(patch, controller);
        } // If it is void and inline data should be patched


        var node = findLastKnownEditorNodeInPath(rootBlock, patch.path); // eslint-disable-next-line max-depth

        var isVoid = controller.query('isVoid', node); // eslint-disable-next-line max-depth

        if (isVoid && node && node.object === 'inline') {
          return patchInlineData(patch, controller, node);
        } // Everything else is patching of spans
        // eslint-disable-next-line max-depth


        if (patch.type === 'insert' || patch.type === 'set' || patch.type === 'diffMatchPatch') {
          return patchSpanText(patch, controller, findTextNodeFromPathKey(rootBlock, findLastKey(patch.path)), rootBlock);
        }
      } // Everything else is patching of custom block data


      return patchVoidBlockData(patch, controller);
    } // Patches working on whole blocks or document


    switch (patch.type) {
      case 'set':
        return setPatch(patch, controller);

      case 'setIfMissing':
        return setIfMissingPatch(patch, controller);

      case 'insert':
        return insertPatch(patch, controller);

      case 'unset':
        return unsetPatch(patch, controller);

      default:
        throw new Error("Don't know how to handle the patch ".concat(patch.type));
    }
  };
}